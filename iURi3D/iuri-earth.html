<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>iURi Holographic UI</title>
    <style>
        :root {
            --primary-color: #ff4040; /* Rojo met√°lico */
            --background-color: #2e4f4f; /* Verde musgo */
        }

        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(#2e4f4f, #1a3c34); /* Fondo oscuro */
            font-family: Arial, sans-serif;
            color: #fff;
        }

        #hologram-container {
            position: relative;
            width: 100vw;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center; /* Simplificado */
            perspective: 1200px;
            z-index: 1;
        }

        #sphere {
            width: 150px;
            height: 150px;
            border-radius: 50% !important;
            background: linear-gradient(to right, #4b0000, #ff6666); /* Fallback */
            transform: perspective(1200px) translateZ(200px);
            animation: pulse 4s ease-in-out infinite;
            transition: transform 0.3s;
            touch-action: manipulation;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden; /* Compatibilidad */
            will-change: transform;
            background-size: cover;
            background-position: center;
            position: relative;
            z-index: 2;
        }

        #sphere.recording {
            background: linear-gradient(to right, #cc7000, #ffdb4d); /* Naranja */
            transform: perspective(1200px) translateZ(0px) scale(1.2);
        }

        #sphere.releasing {
            background: linear-gradient(to right, #1a6b1a, #33ff99); /* Verde */
            transform: perspective(1200px) translateZ(200px);
            animation: vibrate 0.5s linear;
        }

        #sphere.responding {
            background: linear-gradient(to right, #b01030, #ff9999); /* Rojo */
            animation: glow 1.5s ease-in-out;
        }

        @keyframes pulse {
            0%, 100% { transform: perspective(1200px) translateZ(200px) scale(1); }
            50% { transform: perspective(1200px) translateZ(200px) scale(1.1); }
        }

        @keyframes vibrate {
            0%, 100% { transform: perspective(1200px) translateZ(200px); }
            25% { transform: perspective(1200px) translateZ(200px) translateX(2px); }
            75% { transform: perspective(1200px) translateZ(200px) translateX(-2px); }
        }

        @keyframes glow {
            0%, 100% { transform: perspective(1200px) translateZ(200px); }
            50% { transform: perspective(1200px) translateZ(200px) scale(1.15); }
        }

        #history {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            max-height: 0;
            overflow-y: auto;
            background: rgba(46, 79, 79, 0.8);
            color: #fff;
            transition: max-height 0.3s;
            padding: 0 10px;
            box-sizing: border-box;
            z-index: 3;
        }

        #history.active {
            max-height: 200px;
            padding: 10px;
        }

        #history p {
            margin: 5px 0;
            font-size: 14px;
        }

        #controls {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 3;
        }

        #controls button {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: #fff;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }

        #history-toggle {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: #fff;
            padding: 8px;
            border-radius: 50%;
            cursor: pointer;
            z-index: 3;
        }

        #wave-canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
            width: 225px;
            height: 225px;
            z-index: 2;
        }

        #sphere.recording ~ #wave-canvas {
            display: block !important;
        }
    </style>
</head>
<body>
    <div id="hologram-container">
        <div id="sphere" class="sphere"></div>
        <canvas id="wave-canvas"></canvas>
    </div>
    <div id="history" role="log" aria-live="polite"></div>
    <div id="controls">
        <button onclick="playAudio()" aria-label="Reproducir">‚ñ∂</button>
        <button onclick="pauseAudio()" aria-label="Pausar">‚è∏</button>
        <button onclick="replayAudio()" aria-label="Repetir">üîÑ</button>
    </div>
    <button id="history-toggle" aria-label="Mostrar historial">üí¨</button>

    <script>
        // Simulaci√≥n de audio (para el prototipo, sin backend real)
        let audioContext = null;
        let analyser = null;
        let isRecording = false;
        let audioBlob = null;
        let zoomLevel = 1;
        let initialDistance = 0;
        const history = [];

        // Obtener ubicaci√≥n del usuario
        function updateEarthTexture(lat, lon) {
            console.log(`Actualizando textura: lat=${lat}, lon=${lon}`);
            const mapUrl = `https://maps.googleapis.com/maps/api/staticmap?center=${lat},${lon}&zoom=10&size=150x150&maptype=satellite&key=AIzaSyBpFIsikLVKSZ9yWzIC0J61c138pSmh-os`;
            const sphere = document.getElementById('sphere');
            sphere.style.backgroundImage = `url(${mapUrl})`;
            // Verificar carga de la imagen
            const img = new Image();
            img.src = mapUrl;
            img.onload = () => {
                console.log('Textura de Google Maps cargada correctamente');
            };
            img.onerror = () => {
                console.error('Error al cargar la textura de Google Maps');
                addToHistory('Sistema', 'Error al cargar el mapa, verifica la clave API o conexi√≥n');
                sphere.style.backgroundImage = ''; // Volver al gradiente
            };
        }

        navigator.geolocation.getCurrentPosition(
            position => {
                const lat = position.coords.latitude;
                const lon = position.coords.longitude;
                console.log(`Ubicaci√≥n obtenida: ${lat}, ${lon}`);
                updateEarthTexture(lat, lon);
            },
            error => {
                let errorMessage = 'Error desconocido de geolocalizaci√≥n';
                switch (error.code) {
                    case error.PERMISSION_DENIED:
                        errorMessage = 'Permiso de geolocalizaci√≥n denegado. Habilita la ubicaci√≥n en tu navegador (Configuraci√≥n > Privacidad > Ubicaci√≥n) y dispositivo (Ajustes > Ubicaci√≥n). Usa HTTPS para pruebas.';
                        break;
                    case error.POSITION_UNAVAILABLE:
                        errorMessage = 'Ubicaci√≥n no disponible. Verifica tu conexi√≥n, GPS, o prueba con HTTPS.';
                        break;
                    case error.TIMEOUT:
                        errorMessage = 'Tiempo de espera agotado para obtener la ubicaci√≥n. Intenta de nuevo.';
                        break;
                    default:
                        errorMessage = `Error desconocido: ${error.message}`;
                }
                console.error(`Error de geolocalizaci√≥n: ${error.code} - ${error.message}`);
                addToHistory('Sistema', `${errorMessage} Usando Maric√° como predeterminado.`);
                updateEarthTexture(-22.9244928, -42.8146688); // Maric√° por defecto
            },
            {
                timeout: 5000, // 5 segundos de espera
                maximumAge: 60000, // Usar cach√© de hasta 1 minuto
                enableHighAccuracy: false // Baja precisi√≥n
            }
        );

        // Verificar renderizado de la esfera
        console.log('Inicializando esfera');
        const sphere = document.getElementById('sphere');
        if (!sphere) {
            console.error('Elemento #sphere no encontrado');
            addToHistory('Sistema', 'Error: No se pudo renderizar la esfera');
        } else {
            console.log('Esfera encontrada, estilos aplicados');
        }

        // Esfera y eventos t√°ctiles
        sphere.addEventListener('touchstart', (e) => {
            console.log('Touchstart detectado:', e.touches.length, 'toques');
            if (e.touches.length === 1) {
                if (!isRecording) {
                    isRecording = true;
                    sphere.classList.remove('releasing', 'responding');
                    sphere.classList.add('recording');
                    if (!audioContext) {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        console.log('audioContext creado en touchstart');
                    }
                    startRecording();
                    addToHistory('Usuario', 'Grabando...');
                    navigator.vibrate && navigator.vibrate(50);
                }
            } else if (e.touches.length === 2) {
                initialDistance = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
                sphere.addEventListener('touchmove', handleZoom, { once: true });
            }
        });

        sphere.addEventListener('touchend', () => {
            console.log('Touchend: Deteniendo grabaci√≥n');
            if (isRecording) {
                isRecording = false;
                sphere.classList.remove('recording');
                sphere.classList.add('releasing');
                setTimeout(() => {
                    console.log('Transici√≥n a releasing completada');
                    sphere.classList.remove('releasing');
                    sphere.classList.add('responding');
                    setTimeout(() => {
                        console.log('Transici√≥n a responding completada');
                        sphere.classList.remove('responding');
                        addToHistory('IA', '¬°Hola! Esto es una respuesta simulada.');
                    }, 3000);
                }, 2000);
                stopRecording();
            }
        });

        function handleZoom(e) {
            if (e.touches.length === 2) {
                console.log('Zoom detectado');
                const newDistance = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
                zoomLevel *= newDistance / initialDistance;
                zoomLevel = Math.max(0.5, Math.min(zoomLevel, 3));
                sphere.style.transform = `perspective(1200px) translateZ(200px) scale(${zoomLevel})`;
                initialDistance = newDistance;
                sphere.addEventListener('touchmove', handleZoom, { once: true });
            }
        }

        // Ondas de audio
        const waveCanvas = document.getElementById('wave-canvas');
        const waveCtx = waveCanvas.getContext('2d');
        waveCanvas.width = 225;
        waveCanvas.height = 225;
        let animationFrame;

        function animateWaves() {
            console.log('Animando ondas');
            waveCtx.clearRect(0, 0, waveCanvas.width, waveCanvas.height);
            waveCtx.beginPath();
            waveCtx.moveTo(0, waveCanvas.height / 2);
            for (let x = 0; x < waveCanvas.width; x++) {
                const y = waveCanvas.height / 2 + Math.sin(x * 0.03 + Date.now() * 0.005) * 50;
                waveCtx.lineTo(x, y);
            }
            waveCtx.strokeStyle = '#4682b4'; /* Azul gris√°ceo */
            waveCtx.lineWidth = 6;
            waveCtx.stroke();
            if (isRecording) {
                animationFrame = requestAnimationFrame(animateWaves);
            }
        }

        function startRecording() {
            console.log('Iniciando grabaci√≥n de audio');
            navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
                const source = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();
                source.connect(analyser);
                analyser.fftSize = 2048;
                animateWaves();
            }).catch(err => {
                console.error('Error al acceder al micr√≥fono:', err);
                addToHistory('Sistema', 'Error al acceder al micr√≥fono');
                isRecording = false;
                sphere.classList.remove('recording');
            });
        }

        function stopRecording() {
            console.log('Deteniendo grabaci√≥n de audio');
            cancelAnimationFrame(animationFrame);
            waveCtx.clearRect(0, 0, waveCanvas.width, waveCanvas.height);
            audioBlob = new Blob([], { type: 'audio/webm' });
        }

        // Historial y controles
        function addToHistory(sender, message) {
            history.push({ sender, message });
            document.getElementById('history').innerHTML = history.map(item => `
                <p><b>${item.sender}:</b> ${item.message}</p>
            `).join('');
        }

        function playAudio() {
            if (audioBlob) {
                const url = URL.createObjectURL(audioBlob);
                const audio = new Audio(url);
                audio.play();
            }
        }

        function pauseAudio() {
            console.log('Pausar audio');
        }

        function replayAudio() {
            playAudio();
        }

        document.getElementById('history-toggle').addEventListener('click', () => {
            document.getElementById('history').classList.toggle('active');
        });
    </script>
</head>
<body>
</html>